#!/usr/bin/env python3

"""
Script: compute_medians.py

Description:
This script computes the median values for subsample counts and rows, as well as their frequency versions, from a given input file. The user can specify index columns to include in the output, with default columns being 'aminoAcid_length', 'AA', and 'IMGT_position'.

Expected Inputs:
- A tab-separated input file containing columns for subsample counts, rows, and their frequencies.
- The input file must include columns matching the patterns 'subsample_\\d+_counts', 'subsample_\\d+_rows', 'subsample_\\d+_counts_freq', and 'subsample_\\d+_rows_freq'.Use on SAMPLE_subsampled_freq.tsv files generated by bin/imgt_freqs.py.


Outputs:
- A tab-separated output file containing the original columns (not subsampled that is) and computed median values for subsample counts, rows, and their frequencies.

Usage:
python compute_medians.py --input <input_file> --output <output_file> [--index_columns <column1> <column2> ...]

Arguments:
--input: Path to the input file (required).
--output: Path to the output file (required).
--index_columns: Subset of index columns to include in the output. Default: ['aminoAcid_length', 'AA', 'IMGT_position'].
"""

import argparse
import os
import polars as pl
import re

def compute_medians(input_file, output_file, index_columns, sample_name):
    # Load input
    df = pl.read_csv(input_file, separator="\t")

    # Identify columns
    subsample_count_cols = [c for c in df.columns if re.search(r"subsample_\d+_counts$", c)]
    subsample_row_cols = [c for c in df.columns if re.search(r"subsample_\d+_rows$", c)]
    subsample_count_freq_cols = [c for c in df.columns if re.search(r"subsample_\d+_counts_freq$", c)]
    subsample_row_freq_cols = [c for c in df.columns if re.search(r"subsample_\d+_rows_freq$", c)]

    # Compute row-wise medians using Polars expressions
    subs_counts_name = f"{sample_name}_subs_counts"
    subs_rows_name = f"{sample_name}_subs_rows"
    subs_counts_freq_name = f"{sample_name}_subs_counts_freq"
    subs_rows_freq_name = f"{sample_name}_subs_rows_freq"

    df = df.with_columns([
        pl.concat_list([pl.col(c) for c in subsample_count_cols]).list.eval(pl.element().median()).alias(subs_counts_name),
        pl.concat_list([pl.col(c) for c in subsample_row_cols]).list.eval(pl.element().median()).alias(subs_rows_name),
        pl.concat_list([pl.col(c) for c in subsample_count_freq_cols]).list.eval(pl.element().median()).alias(subs_counts_freq_name),
        pl.concat_list([pl.col(c) for c in subsample_row_freq_cols]).list.eval(pl.element().median()).alias(subs_rows_freq_name),
    ])

    # Flatten nested columns to avoid CSV issues
    df = df.with_columns([
        pl.col(subs_counts_name).list.first().alias(subs_counts_name),
        pl.col(subs_rows_name).list.first().alias(subs_rows_name),
        pl.col(subs_counts_freq_name).list.first().alias(subs_counts_freq_name),
        pl.col(subs_rows_freq_name).list.first().alias(subs_rows_freq_name),
    ])

    # Select columns for output
    output_columns = index_columns + [
        f"{sample_name}_orig_counts",
        f"{sample_name}_orig_rows",
        f"{sample_name}_orig_counts_freq",
        f"{sample_name}_orig_rows_freq",
        subs_counts_name,
        subs_rows_name,
        subs_counts_freq_name,
        subs_rows_freq_name,
    ]

    df.select(output_columns).write_csv(output_file, separator="\t")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Compute medians for subsample counts and rows using Polars.")
    parser.add_argument("--input", required=True, help="Path to input file.")
    parser.add_argument("--sample_name", required=True, help="Sample name prefix used in column names (e.g. F15625E).")
    parser.add_argument(
        "--index_columns",
        nargs="+",
        default=["aminoAcid_length", "AA", "IMGT_position"],
        help="Subset of index columns to include in the output. Default: ['aminoAcid_length', 'AA', 'IMGT_position']"
    )
    parser.add_argument("--output", required=False, help="Path  to output file.")

    args = parser.parse_args()

    # Set default output file name if not provided
    if not args.output:
        base_name = os.path.splitext(os.path.basename(args.input))[0]
        args.output = f"{base_name}_med.tsv"

    compute_medians(args.input, args.output, args.index_columns, args.sample_name)
